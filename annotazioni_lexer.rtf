ANNOTAZIONI AGGIUNTE DAGLI STUDENTI

BARDOZZO Francesco 0522500228, SAULINO Aniello 0522500219 

Testo delle annotazioni:

1. Scelte di progetto ed implementazione
Il progetto per la creazione del Lexer è stato progettato seguendo i diagram states cartacei redatti al fine di rendere più snello e semplice il lavoro di implementazione. Come è possibile evincere dal codice contenuto nel file cool.lex, esistono essenzialmente 5 stati principali: YYINITIAL, STRING, MLCOMMENT, OLCOMMENT e STRING_ERROR. Gli stati sono coadiuvati dalla presenza di espressioni regolari che definiscono le regole per identificare i lessemi che saranno poi elaborati dal Lexer sottoforma di token. Le espressioni regolari riguardano, principalmente:

· WhiteSpace = [\ \r\v\t\n\f]; questa espressione regolare identifica quelli che sono gli spazi bianchi tra i lessemi, in linea con le specifiche del linguaggio Cool;
· ObjectIdentifier = [a-z]([a-zA-Z0-9_]*); espressione regolare atta a rilevare gli identificatori di oggetto. Il nome delle features presenti nelle classi del linguaggio avranno questa composizione;
· TypeIdentifier =  [A-Z]([a-zA-Z0-9_]*); espressione regolare composta per il riconoscimento degli identificatori di tipo. Nel momento in cui verranno creati tipi di dato ( Int, String, Bool,… ), questa espressione regolare permetterà di riconoscerli senza errori. La suddetta, inoltre, permetterà di riconoscere anche i nomi delle classi definite dall'utente in linea con la specifica del linguaggio, secondo la quale il nome di ogni classe deve iniziare con la lettera maiuscola;
· DecimalInt = ([0-9]+); l'espressione regolare che si occupa del riconoscimento di interi decimali. Questi possono essere 1 o più occorrenze di cifre comprese tra 0 e 9.

Forniamo, ora, una breve descrizione di ogni stato presente nel Lexer:

· YYINITIAL: è lo stato principale che presenta il comportamento dell'analizzatore lessicale nel momento in cui avviene il riconoscimento di una delle seguenti situazioni:
· ObjectIdentifier, in cui il Lexer ritorna un nuovo simbolo alla tabella dei simboli di tipo TokenConstants.OBJECTID;
· TypeIdentifier, in cui il Lexer ritorna un nuovo simbolo alla tabella dei simboli di tipo TokenConstants.TYPEID;
· DecimalInt, in cui il simbolo ritornato è TokenConstants.INT_CONST;
· WhiteSpace, la cui regola impone di ignorare qualsiasi azione come da specifica del linguaggio;
· Operatori, nel quale vengono memorizzate le costanti corrispondenti ad ogni operatore binario, come ad esempio "+" che ritorna TokenConstants.PLUS;
· Apertura e chiusura dei commenti multilinea e a linea singola, in cui si entra rispettivamente in altri due stati che sono MLCOMMENT e OLCOMMENT, descritti in seguito.
· STRING: è lo stato in cui viene descritto il comportamento del Lexer nel momento in cui si incontrano entità di tipo String. Nello stato YYINITIAL si può notare la presenza di una regola, precisamente \", che impone l'ingresso nel nuovo stato STRING. Genericamente, se il Lexer incontra la chiusura dei doppi apici ritorna allo stato di partenza YYINITIAL; nel caso in cui, invece, vengono incontrati caratteri quali \\t, \\n, \\b, \\f e \\., il Lexer farà in modo di effettuare l'append dei caratteri privi del primo backslash (\t, \n, \b, \f e \.) previo controllo sulla dimensione della stringa esaminata. Di forte rilievo, infatti, sono le regole che gestiscono gli errori sulle stringhe stesse:
· \000 ritorna l'errore "String contains null character.";
· quando la stringa analizzata risulta essere maggiore della taglia massima impostata (1025), il Lexer restituirà "String constant too long";
· nel momento in cui è presente un \n (newline) all'interno di una stringa racchiusa tra doppi apici, il Lexer provvederà a ritornare l'errore "Unterminated String error".
· Tutti i suddetti errori, oltre a ritornare il rispettivo messaggio, cambiano lo stato del Lexer da STRING a STRING_ERROR.
· STRING_ERROR: descrive le regole per la gestione degli errori nelle stringhe. È stato necessario specificare questo stato in quanto, senza di esso, al verificarsi di un errore nella gestione delle stringhe stesse sarebbe stato impossibile gestire un corretto ritorno allo stato iniziale YYINITIAL. STRING_ERROR prevede la seguente casistica:
· \";
· \n;
· \\\n
· \\. | .
	  I casi a, b e c prevedono il ritorno allo stato iniziale YYINITIAL (b e c prevedono anche l'incremento di una 		  variabile curr_lineno per il conteggio delle righe di codice esaminate dal Lexer), mentre lo stato d gestisce tutti 	  gli altri caratteri letti dal Lexer stesso.
· MLCOMMENT: è lo stato impegnato nella gestione dei commenti multilinea, qualora l'analizzatore lessicale ne incontri la presenza. I caratteri di ingresso per questo stato sono "(*", definiti in YYINITIAL; la gestione è piuttosto semplice: all'occorrenza del carattere di apertura del commento multilinea, una variabile contatore parenthesesCounter viene incrementata; all'occorrenza del lessema di chiusura "*)", la suddetta viene decrementata e l'analizzatore lessicale effettua il controllo sul numero di parentesi aperte: nel momento in cui questo risulta essere 0, si ritorna allo stato iniziale YYINITIAL. Tutti i caratteri sono gestiti tramite la regola "." che non prevede nessuna azione. 
· OLCOMMENT: codifica i comportamenti dell'analizzatore lessicale nel momento in cui occorre il commento a linea singola, rappresentato dal lessema "--" nello stato iniziale YYINITIAL. Al verificarsi di una newline, la regola impone il ritorno al suddetto stato iniziale (ciò accade quando nel codice dato in pasto al Lexer viene terminato il commento e si va a capo), mentre tutti gli altri casi sono rappresentati dalla regola "." per cui non è prevista alcuna azione.

Quando l'analizzatore lessicale incontra un EOF (EndOfFile), nel blocco %eofval{} si trovano le istruzioni specificate in linguaggio Java per gestire questa particolare situazione. Precisamente, nel caso in cui l'ultimo stato in cui l'analizzatore lessicale era STRING o STRING_ERROR, il Lexer ritorna un errore di "EOF in String constant". Nel caso in cui, invece, lo stato attuale fosse MLCOMMENT, la gestione prevede il ritorno di "EOF in comment". C’è da sottolineare che con la nuova versione di lexer è possibile utilizzare un token speciale chiamato <<EOF>> e soppiantare l’area di codice specificata da %eofval. In questa modalità di utilizzo, basta creare o ripetere uno stato nello specificatore con lo special token <<EOF>> e l’anciare l’errore:

/* <STRING_ERROR, STRING, MLCOMMENT, OLCOMMENT> { 
        <<EOF>> {    yybegin(YYINITIAL);
		         return new Symbol(TokenConstants.ERROR, "EOF error");} } */







2. Descrizione dei propri test e perché sono adeguati
Il Lexer prodotto è stato sottoposto a validazione con successo e testati con file suggeriti dal testo dell'assignement, ovvero 0_good.cl e 1_bad.cl. Sono stati prodotti, inoltre, 20 files con estensione cl nei quali si è cercato di riprodurre tutte le condizioni verificabili al momento della compilazione di un file in linguaggio Cool. I suddetti files sono allegati nella cartella lexerStudent presente nell'archivio sottomesso sulla piattaforma.  





3. Breve convincimento che il codice prodotto è corretto
Il risultato della sottomissione al validatore è stato il seguente:
JFLEX... done.
JAVAC... done.
Similarity with other submissions... done.

0 execution error(s).

Strict diff:
0 files changed
118 equal files (118 source files).
Ciò suggerirebbe una corretta composizione del codice del Lexer. Il team di sviluppo, ha ovviamente, condotto gli altri test di verifica comparando il risultato del Lexer fornito come materiale didattico a quello da esso stesso prodotto: i risultati sono stati identici su tutti e 20 i files. Si suppone, con un basso margine di dubbio, la correttezza del Lexer programmato.

